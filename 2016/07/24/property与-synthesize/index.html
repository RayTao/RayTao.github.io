<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>@property与@synthesize | Hexo</title>
  <meta name="author" content="John Doe">
  
  <meta name="description" content="@property与@synthesize#property属性12提供成员变量的访问方法的声明、控制成员变量的访问权限、控制多线程时成员变量的访问环境。property不但可以在interface，在协议protocol.和类别category中也可以使用。
#synthesize 合成访问器方法">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="@property与@synthesize"/>
  <meta property="og:site_name" content="Hexo"/>

  
    <meta property="og:image" content="undefined"/>
  

  <link href="/favicon.ico" rel="icon">
  <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  <link rel="stylesheet" href="//netdna.bootstrapcdn.com/bootstrap/3.1.0/css/bootstrap.min.css">
<link rel="stylesheet" href="//netdna.bootstrapcdn.com/font-awesome/4.0.3/css/font-awesome.css">
<link rel="stylesheet" href="/css/style.css">
  <script src="http://code.jquery.com/jquery-2.1.1.min.js"></script>
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-368771XX-X']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>

</head>

<body>
  <header id="header" class='normal_mode'>
    <nav id="main-nav">
  <ul class='container'>
    
      <li><a href="/">Home</a></li>
    
      <li><a href="/archives">Archives</a></li>
    
  </ul>
  <div class="clearfix"></div>
</nav>
  </header>
  <div id="content" class="container">
    <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
      <time datetime="2016-07-24T10:07:15.000Z"><a href="/2016/07/24/property与-synthesize/">Sun, Jul 24 2016, 6:07:15 pm</a></time>

  
    <h1 class="title">@property与@synthesize</h1>
  



  
  <div class="tags">
  	<i class="fa fa-tag"></i>
    <a href="/tags/Obj-C语法/">Obj-C语法</a>
  </div>

<div class="clear"></div>
      
    </header>
    <div class="entry">
      
        <h1 id="property与-synthesize"><a href="#property与-synthesize" class="headerlink" title="@property与@synthesize"></a>@property与@synthesize</h1><p>#property属性<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">提供成员变量的访问方法的声明、控制成员变量的访问权限、控制多线程时成员变量的访问环境。</div><div class="line">property不但可以在interface，在协议protocol.和类别category中也可以使用。</div></pre></td></tr></table></figure></p>
<p>#synthesize 合成访问器方法<br><figure class="highlight obj-c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">实现property所声明的方法的定义。其实说直白就像是：property声明了一些成员变量的访问方法，synthesize则定义了由property声明的方法。</div><div class="line"></div><div class="line">他们之前的对应关系是:property 声明方法 -&gt;头文件中申明<span class="keyword">getter</span>和<span class="keyword">setter</span>方法 synthesize定义方法 -&gt; m文件中实现<span class="keyword">getter</span>和<span class="keyword">setter</span>方法。</div><div class="line"></div><div class="line">在Xcode4<span class="number">.5</span>及以后的版本中，可以省略<span class="keyword">@synthesize</span>，编译器会自动帮你加上get 和 set 方法的实现，并且默认会去访问_age这个成员变量，如果找不到_age这个成员变量，会自动生成一个叫做 _age的私有成员变量。在.m文件中同时实现<span class="keyword">getter</span>和<span class="keyword">setter</span>时候需要<span class="keyword">@synthesize</span> age = _age.</div></pre></td></tr></table></figure></p>
<p>##1.读写特性：readonly 、readwrite<br><figure class="highlight obj-c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">在Objective-C中，拥有这样两个读写特性：<span class="keyword">readwrite</span>和<span class="keyword">readonly</span>，意思简单明了，就是可读可写以及只读。默认情况下，属性默认是可读可写的。</div></pre></td></tr></table></figure></p>
<p>##2.setter语意<br><figure class="highlight obj-c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">  <span class="keyword">setter</span>语意特性主要是用来告诉Xcode，对于这个属性，应该如何去自动实现它的<span class="keyword">setter</span>方法。这个特性主要是针对非ARC情况的。</div><div class="line">  在Objective-C中，拥有三个<span class="keyword">setter</span>语意特性：<span class="keyword">assign</span>、<span class="keyword">retain</span>和<span class="keyword">copy</span>，默认情况下属性特性是<span class="keyword">assign</span>的。</div><div class="line"></div><div class="line">  <span class="keyword">assign</span>:简单赋值特性，它不会对索引计数（Reference Counting）进行更改。默认类型,<span class="keyword">setter</span>方法直接赋值，而不进行<span class="keyword">retain</span>操作</div><div class="line">-(<span class="keyword">void</span>)setStr:(<span class="built_in">NSString</span>*)value&#123;  </div><div class="line">    str=value;  </div><div class="line">&#125; </div><div class="line"></div><div class="line">  <span class="keyword">retain</span>:<span class="keyword">setter</span>方法释放(release)旧的对象，然后将旧对象的值赋予输入对象，再将输入对象的索引计数增加<span class="number">1</span>（<span class="keyword">retain</span>）。</div><div class="line">-(<span class="keyword">void</span>)setStr:(<span class="built_in">NSString</span>*)v&#123;  </div><div class="line">    <span class="keyword">if</span>(v!=str)&#123;  </div><div class="line">        [str release];  </div><div class="line">        str=[v <span class="keyword">retain</span>];</div><div class="line">    &#125;  </div><div class="line">&#125; </div><div class="line"></div><div class="line">  <span class="keyword">copy</span>:<span class="keyword">setter</span>方法进行Copy操作，与<span class="keyword">retain</span>一样,建立一个索引计数为<span class="number">1</span>的对象，释放掉旧对象。</div><div class="line">-(<span class="keyword">void</span>)setStr:(<span class="built_in">NSString</span>*)v&#123;  </div><div class="line">    <span class="keyword">if</span>(v!=str)&#123;  </div><div class="line">        [str release];  </div><div class="line">        str=[v <span class="keyword">copy</span>];</div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>###什么时候使用这些语意特性呢？<br>  只要是值类型、简单类型的类型，比如说NSInteger、CGPoint、CGFloat，以及C数据类型int、float、double等，都应该使用assign。<br>  那么对于含有可深复制子类的对象，比如说NSArray、NSSet、NSDictionary、NSData、NSString等等，都应该使用copy特性。</p>
<pre><code>注意：对于NSMutableArray之类的可变类型，不能够使用Copy特性，否则初始化会出现错误。
</code></pre><p>  至于其他的NSObject对象，那么都应该使用retain来进行操作，这也是绝大多数所使用的情况。</p>
<p>##3.所有者特性<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">对于ARC来说，上一节中所说的getter语意特性将被所有者特性所代替。</div><div class="line"></div><div class="line">在Objective-C中，拥有两个所有者特性：strong和weak。默认情况下属性特性是strong的。</div><div class="line"></div><div class="line">对于strong来说，它就相当于getter语意特性中的retain特性，即这个特性的属性将会成为对象的持有者。这个特性称之为强引用。</div><div class="line">@property(strong) MyClass *myObject;</div><div class="line">相当于@property(retain) MyClass *myObject;</div><div class="line"></div><div class="line">对于weak来说，它声明的属性不会拥有这个对象的所有权，如果弱引用指向的对象被deallocated的话，弱引用的对象会被自动设置为nil。</div><div class="line">@property(weak) MyOtherClass *delegate;</div><div class="line">相当于@property(assign) MyOtherClass *delegate;</div><div class="line"></div><div class="line">简单讲strong等同retain</div><div class="line">weak比assign多了一个功能，当对象消失后自动把指针变成nil，好处不言而喻。</div><div class="line"></div><div class="line">强引用与弱引用的广义区别：</div><div class="line">  强引用也就是我们通常所讲的引用，其存亡直接决定了所指对象的存亡。如果不存在指向一个对象的引用，并且此对象不再显示列表中，则此对象会被从内存中释放。</div><div class="line">  弱引用除了不决定对象的存亡外，其他与强引用相同。即使一个对象被持有无数个若引用，只要没有强引用指向他，那麽其还是会被清除。</div><div class="line"></div><div class="line">面对ARC机制中，最令人头疼的就是“循环强引用”的问题，所谓循环强引用，就是我们申请了两个保险柜，然后分别将另外一个保险柜的钥匙锁在了保险柜当中。这样就会造成什么现象呢？我们完全就无法归还钥匙了，这两个保险柜就无法再重新使用了。那么使用弱引用，就不会出现这个问题了。</div></pre></td></tr></table></figure></p>
<pre><code>weak常用于网络delegate属性
</code></pre><p>##原子特性<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">原子特性，简要来说，是针对多线程而设置的。Objective-C拥有两种原子特性，分别是atomic和nonatomic。</div><div class="line"></div><div class="line">我们知道，如果使用多线程的话，有时会出现两个线程互相等待而导致的死锁现象。使用atomic特性，Objective-C可以防止这种线程互斥的情况发生，但是会造成一定的资源消耗。这个特性是默认的。</div><div class="line"></div><div class="line">而如果使用nonatomic，就不会有这种阻止死锁的功能，但是如果我们确定不使用多线程的话，那么使用这个特性可以极大地改善应用性能。</div><div class="line"></div><div class="line">相比之下，swift目前还不支持这些特性。如果我们要实现线程安全，似乎只能使用objc_sync_enter此类的方法，来保证属性的处理只有一个线程在进行。或者使用属性观察器来完成这些操作。</div></pre></td></tr></table></figure></p>
<p>##总结<br>  我们总共介绍了四种属性特性，分别是读写特性、setter语意特性、所有者特性和原子特性。ARC是不支持setter语意特性的，它使用所有者特性。</p>

      
    </div>
    <footer>
      
          
<!-- JiaThis Button BEGIN -->
<div class="jiathis_style">
  <span class="jiathis_txt">分享到：</span>
  <a class="jiathis_button_weixin">微信</a>
  <a class="jiathis_button_tsina">新浪微博</a>
  <a class="jiathis_button_renren">人人网</a>
  <a class="jiathis_button_qzone">QQ空间</a>
  <a class="jiathis_button_douban">豆瓣</a>
  <a class="jiathis_button_pocket">Pocket</a>
  <a href="http://www.jiathis.com/share?uid=901656" class="jiathis jiathis_txt jiathis_separator jtico jtico_jiathis" target="_blank">更多</a>
  <a class="jiathis_counter_style"></a>
</div>
<script type="text/javascript" src="http://v3.jiathis.com/code_mini/jia.js?uid=901656" charset="utf-8"></script>
<!-- JiaThis Button END -->

          <div class="clearfix"></div>
          <nav id="pagination">
  
  
  <div class="clearfix"></div>
</nav>
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>


<section id="comment">
  <h1 class="title">Kommentare</h1>

  
      <!-- Duoshuo Comment BEGIN -->
<div class="ds-thread" data-thread-key="/2016/07/24/property与-synthesize/"></div>
<!-- Duoshuo Comment END -->
  
</section>



    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div>
  
  &copy; 2016 John Doe
  
</div>
Powered by <a href="http://zespia.tw/hexo/" title="Hexo" target="_blank" rel="external">Hexo</a> and <a href="http://pages.github.com/" title="GitHub Pages" target="_blank" rel="external">GitHub Pages</a>

<div class="clearfix"></div></footer>
  
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="//netdna.bootstrapcdn.com/bootstrap/3.1.0/js/bootstrap.min.js"></script>




    <script type="text/javascript">
        (function(){

            $(window).scroll(function(){

                var scrollTop = $(window).scrollTop();
                if ( scrollTop >200 ){
                    $("#main-nav").removeClass('normal_mode').addClass('top_mode');
                } else{
                    $("#main-nav").removeClass('top_mode').addClass('normal_mode');
                }

            });

        })();
    </script>



  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>
  <script type="text/javascript">
  (function($){
    $('.fancybox').fancybox({
      'titlePosition': 'inside'
    });
  })(jQuery);
  </script>



    
    <script type="text/javascript">
      var duoshuoQuery = {short_name:"your_id"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.src = 'http://static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0] 
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>



<script type="text/javascript">
  
  $(function(){

    $('.title').hover(
      function() {      
        $(this).stop().animate(
          {'marginLeft': '10px'}, 200
        );   
      }, 
      function() {       
        $(this).stop().animate({'marginLeft': '0px'}, 200);      
      
    });   

  });

</script>


</body>
</html>